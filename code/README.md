# Zilog Z80 Curiosity Board #2 - The KIO Version : Software

## The Z80 Monitor 
The MONZ80-RAM.ASM file contains a modified version of the excellent Z80 monitor called MONZ80 written by [Dave Dunfield](https://dunfield.themindfactory.com/). You can find the source code to the Z80 monitor along with monitors for other micros in the MONITORS.ZIP file on Dave's website. The monitor code needs a slight tweek to reflect the addresses of the SIO registers within the KIO chip. There's additional code to setup the KIO, handle the copying of the ROM into RAM and the disabling of the ROM.

MONZ80 can be assembled using the free online assembler at [ASM80.COM](https://asm80.com) - select the Z80 CPU.

I've not managed to locate a user manual for MONZ80 so I have included the user manual for MON85 as a guide to MONZ80.

# The Monitor and BASIC v4.7

## The Monitor (monitor.asm)

The simple monitor program is essentially Grants monitor program but modified to take into account the different addresses of the CompactFlash and SIO registers in my design. The monitor also copies itself into RAM and disables the ROM. The baud rate is also set to 57600 baud (rather than 115200 baud).

The main change is the use of SIO channel B. My Z80 KIO curiosity board doesn't have a hard wired clock into the SIO channel B TxCLKB & RxCLKB pins. Without a clock on TxCLKB, any byte in the TxB register will stay there forever and any code that waits for the Tx Buffer Empty bit to clear will hang forever.

As a result of this, the code expects a terminal connection on SIO channel A. I've added a constant called USE_SIOB which can be set to 0 to ignore SIO channel B or set to a 1 to also use SIO channel B. Setting USE_SIOB to a 1 will let the code detect a terminal on either SIO channel.

There are also some hard coded values that tell the monitor where to find BASIC. I've added a new value called BASSIZE which is the rough amount of ROM space that BASIC occupies. It is only needed when copying BASIC from ROM to RAM and I've set it to $2000.
 
## BASIC v4.7 (basic.asm)

I've modified the version of BASIC that Grant used so that it can be assembled using ASM80. Other than that, the code is identical.

The Intel-Hex file can be programmed into the ROM at the same time as the monitor or it can be loaded into RAM using the monitor. 

# Installing CP/M

These are my notes for loading CP/M onto the board, which are almost identical to Grants instructions and include any modifications I may have done to his code.

  
## A simple LED flasher
The LEDTest folder contains a simple piece of assembler code that flashes the 2 onboard LEDs. The code was assembled using the [ASM80](https://www.asm80.com/) online assembler. Set the CPU type to 8080 when creating the file. I've also put the listing file generated by ASM80 into the LEDTest folder along with the Intel-HEX file that can be loaded using MON85. The code is designed to load at address 0x5000 and run from that address.

## A simple LED flasher in RAM
The LEDTest2 folder contains the same simple LED flashing code as above, BUT demonstates an interesting feature. Note that this code should only be used with the MON85 ROM monitor - it won't work with the MON85 RAM monitor.

The MON85 monitor resides in ROM starting at address 0x0000. The downside of this is usually that you cannot put your own interrupt handlers there as it's Read Only. However, with the RetroDuino-8085 design, you can!

Using the MON85 L command, load the LEDTest2 Intel-HEX file. This will load the LED flashing code into RAM at address 0x0000. Even though the MON85 ROM resides in this area, MON85 can actually write to the RAM at the same address - it just can't read from that RAM. Any attempt to read from this area will read the ROM - i.e MON85.

In order to run the code, give MON85 the command "g FF80". There is a small piece of code that is pre-loaded by MON85 that resides at this address. This simple bit of code sets the 8085 SOD pin high - switching out the MON85 ROM completely - and then jumps to address 0x0000 to execute whatever code it finds there.

You can put whatever code you like into low memory and run it just like it would run from ROM.

The downside is that once the ROM is switched out, you loose all the MON85 capabilities like inspecting and modifying memory, setting breakpoints etc.

# z88dk - The z80 development kit

## A Simple Hello
I've figured out how to use the [z88dk](https://z88dk.org/site/) suite to create some code for the RetroDuino-8085. I'm completely new to the z88dk tools so look away now if you've already got experience of using z88dk as what follows might not be pretty! Expect dragons!

The traditional ["Hello World"](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program) code was created by following the [Classic Homebrew](https://github.com/z88dk/z88dk/wiki/Classic--Homebrew) hardware quick start guide and includes console input. As the RetroDuino-8085 can run code from address 0x0000, I've also got a basic crt0 file as well. It's all in the simple_hello folder along with the batch file I used to build the code.

Use the MON85 L command to load the Intel-HEX file and then give MON85 the command "g FF80" to switch out the ROM and run the code.

## Some more useful software
After a bit of experimentaion, I now have a software SPI interface and a software I2C interface. The code is in the z88dk spi-i2c folder.

There's a sys folder now that includes the following:
| File | Description |
| :---- | :---- |
| hardware.c | c source file that handles SPI, I2C & the UART timer |
| hardware.h | function prototypes |
| low_level.asm | low level assembler functions
| rd85_crt0.asm | startup code for the RetroDuino-8085|

I've also included 3 example programs - main_timer.c, main_spi.c and main_i2c.c which show how to use the software SPI, software I2C and the system tick (currently set to increment every 20mS).

Rename the main_*.c file to simply main.c and the build script should work to demonstrate SPI, I2C or system tick. 